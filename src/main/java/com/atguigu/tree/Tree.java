package com.atguigu.tree;

import java.util.ArrayList;

public class Tree {

    /**
     *
     * 数：
     *
     * 集合ArrayList:
     * 底层机制：
     * 1.ArrayList维护了一个object类型的数组 elementData
     * 2.当创建对象时，如果使用的时无参构造器，则初始 elementData 容量为0（jdk1.7 是 10）
     * 3.如果使用的是指定容量capacity的构造去，则初始容量为 capacity
     * 4.当添加元素是，判断是否需要扩容，如果需要扩容，则调用grow（）方法，否则直接添加元素到指定位置
     * 5.如果使用的是无参构造去，如果第一次添加，需要扩容的话，则扩容 elementData 为 10，如果
     * 需要再次扩容的话，则扩容为 elementData 的1.5倍
     * 6.如果使用的是指定容量capacity的构造器，如果需要扩容，则直接扩容 elementData 为1.5倍
     *
     * 二叉树（每个节点最多只有两个子节点）
     * 数组存储方式：
     * 优点：通过下标方式访问元素，速度快，对于有序数组，可以用二分查找提高检索速度
     * 缺点：如果要检索具体某个值，或者插入值（按一定顺序），会整体移动，效率较低
     *
     * 数组扩容：每次在底层都需要创建新数组，将原来的数据拷贝到新数组，并插入新的数据
     * 集合底层也是维护了一个object[]数组
     *
     * 链式存储方式：
     * 优点：在一定程度上对数组存储有优化（比如插入一个数值节点，只需要将插入节点链接到链表中，删除效率也很好）
     * 缺点：在进行检索式，效率任然低，（如检索某个值，需要从头节点开始遍历）
     *
     *
     * 树存储方式：
     * 能提高数据存储，读取效率。如利用二叉排序树，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改速度
     *
     *
     * 满二叉树：该二叉树的所有叶子节点都在最后一层，且节点总数为 2^n - 1, n为层数;
     * 完全二叉树：如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，
     * 倒数第二层的叶子节点在右边连续
     *
     *
     * 二叉树遍历
     * 创建一颗二叉树
     * 1.前序
     *   1.1 先输出当前节点（初始为根节点root）
     *   1.2 如果左子节点不为空，则递归继续前序遍历
     *   1.3 如果右子节点不为空，则递归继续前序遍历
     * 2.中序
     *   2.1 如果左子节点不为空，则递归继续中序遍历
     *   2.2 输出当前节点
     *   2.3 如果右子节点不为空，则递归继续中序遍历
     * 3.后序
     *   3.1 如果左子节点不为空，则递归继续后序遍历
     *   3.2 如果右子节点不为空，则递归继续后序遍历
     *   3.3 输出当前节点
     *
     *
     *
     * 二叉树查找
     * 1.前序
     *   1.1 先判度当前节点是否是要查找的，如果是，返回
     *   1.2 如果不是，判断当前节点的左节点是否为空，不为空，前序递归查找，找到节点，返回，
     *   1.3 如果没有找到，继续判断当前节点的右节点是否为空，不为空，前序递归查找，返回
     * 2.中序
     *   2.1 判断当前节点的左节点是否为空，不为空，中序递归查找，找到节点，返回
     *   2.2 如果没有找到，判断当前节点是否是要查找的，是，返回
     *   2.3 如果不是，继续判断当前节点的右节点是否为空，不为空，中序递归查找，返回
     * 3.后序
     *   3.1 判断当前节点的右节点是否为空，不为空，后序递归查找，找到返回
     *   3.2 没有找到，继续判断当前节点的左节点是否为空，不为空，后序递归查找，返回
     *   3.3 没有找到，判断当前节点是否是要查找的值，返回
     *
     *
     * 二叉树删除节点
     * 要求：
     * 1.如果要删除的节点是叶子节点，则删除该节点
     * 2.如果要删除的节点是非叶子节点，则删除该子树
     * 3.测试，删除7号叶子节点和5号子树
     *
     * 思路：
     * 1.首先如果树是空树，即只有一个root节点，则等价于将二叉树置空
     * 2.判断当前节点的子节点是否是要删除的节点
     *   2.1如果当前节点的左子节点不为空，且就是要删除的节点，则this.left = null,返回
     *   2.2如果当前节点的右子节点不为空，且就是要删除的节点，则this.right = null,返回
     * 3.如果第二步没有删除节点，则需要向左子树/右子树递归进行删除
     *
     *
     *
     * 顺序存储二叉树
     * 即数组可以转换成树，树也可以转换成数组
     *
     * 特点：
     * 1. 顺序二叉树通常只考虑完全二叉树
     * 2. 第n个元素的左子节点为 2*n + 1
     * 3. 第n个元素的右子节点为 2*n + 2
     * 4. 第n个元素的父节点为 (n - 1) / 2
     *
     * n: 表示二叉树中的第几个元素（按0开始编号）
     *
     * 要求：给一个数组arr = {1，2，3，4，5，6，7}，在遍历该数组是，任然可以以二叉树的前序遍历，
     *      中序遍历，后序遍历
     *
     *
     * 顺序存储二叉树应用：堆排序
     *
     *
     *
     * 线索二叉树
     * 1. n个节点的二叉链表中右 n + 1 个空指针域，利用二叉链表中的空指针域，存放指向该节点的某种
     * 遍历次序下的前驱节点和后继节点的指针，这种附加的指针称为 线索
     * 2. 这种加上了线索的链表称为线索链表，相应的二叉树称为线索二叉树（前序，中序，后序线索二叉树）
     * 3. 一个节点的前一个节点称为前驱节点，后一个节点称为后继节点
     *
     * 说明
     * 1.当线索化二叉树后，node节点的属性left 和 right 有以下情况
     *   1.1 left指向的可能是左子树，也可能是指向前驱节点
     *   1.2 right指向的可能是右子树，也可能是指向后继节点
     *

     *
     *
     * 前序线索化二叉树
     *   node == null, 直接返回
     * 1.线索化当前节点
     *   1.1 处理前驱节点：让当前节点的左指针指向前驱节点；修改当前节点的左指针类型为1指向前驱节点
     *   1.2 处理后继节点：让前驱节点的右指针指向后继节点，修改前驱节点的右指针类型为1指向后继节点
     *   1.3 每处理完一个节点后，让当前节点是下一个节点的前驱节点
     * 2.线索化左子树
     *   判断当前节点的左指针类型不能为前驱节点，线索化
     * 3.先说话右子树
     *   判断当前节点的右指针类型不能为后继节点，线索化
     *
     * 中序线索化二叉树
     * 1.线索化左子树
     *   线索化
     * 2.线索化当前节点
     *   同上 1
     * 3.线索化右子树
     *   线索化
     *
     * 后序线索化二叉树
     * 1.线索化左子树
     *   线索化
     * 2.线索化右子树
     *   线索化
     * 3.线索化当前节点
     *   同上 1
     *
     *
     *
     * 前序遍历线索化二叉树
     * 1. 定义一个变量node 存储当前遍历的节点，从root开始
     * 2. 循环遍历，先输出该节点，找到leftType == 1 的节点
     * 3. 输出该节点
     * 4. 获取当前节点的后继节点
     *
     * 中序遍历线索化二叉树
     * 1. 定义一个变量node 存储当前遍历的节点，从root开始
     * 2. 循环找到leftType == 1的节点，并打印该节点
     * 3. 如果该节点的右指针指向的是他的后继节点，则一直输出
     * 4. 获取到当前节点的后继节点
     * 5. 循环完后，替换这个遍历的节点
     *
     *
     *
     * 后序遍历线索化二叉树（左右根）
     *  增加父节点指针parent，在创建二叉树是要保存parent
     * 1. 定义一个变量node 存储当前遍历的节点，从root开始
     * 2. 循环找到leftType == 1的节点
     * 3. 沿着right指针进行处理，当right不是后继指针，并且上一个处理节点时当前节点的右节点
     *    则处理当前节点的右子树
     * 4.当前节点时root节点且上一个节点时root的right节点，遍历完
     *
     *
     *
     *
     * 前序，中序，后序线索化比较：
     * 1.前序遍历的顺序是：根左右，所以从根节点开始，沿着左子树进行处理，当子节点的left指针类型是
     * 线索（leftType == 1）时,说明到了最左子节点，然后处理子节点的right指针指向的节点，可能是
     * 右子树，可可能是后继节点，无论是那种类型继续按照上面的方式（沿着左子树处理，找到最左子节点，
     * 然后处理right指针指向），以此类推，直到节点的right指针为空，说明是最后一个，遍历完成
     * 2.中序遍历的顺序是：左根右，因此第一个节点一定是最左子节点，先找到最左字节顶，然后沿着right
     * 指针指向进行处理（无论是指向子节点还是后继节点），直到节点的right指针为空，说明是最后一个，
     * 遍历完成
     * 3.通用的二叉树节点存储结构不能满足后序线索化，因此我们增加了父节点的指针，后序遍历的顺序是：
     * 左右根，先找到最左子节点，沿着right指针指向进行处理，当right不是后继指针时，并且上一个处理
     * 节点是当前节点的右节点，则处理当前节点的右子树，遍历终止条件实，当前节点是root节点，并且上一
     * 个处理的节点是root的right节点
     *
     *
     *
     *
     * 树结构的实际应用：堆排序
     * 堆是具有以下性质的完全二叉树：
     * 1.每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；
     *   特点：arr[i] > arr[2 * i + 1] && arr[i] > arr[2 * i + 2],i为对应的第几个节点，编号从0开始
     *   一般升序采用大顶堆
     * 2.每个节点的值都小于或等于其左右孩子节点的值，称为小顶堆；
     *   特点：arr[i] < arr[2 * i + 1] && arr[i] < arr[2 * i + 2],i为对应的第几个节点，编号从0开始
     *   降序采用小顶堆
     *
     *
     * 堆排序基本思想
     * 1.将待排序系列构建成一个大顶堆
     *   从最后一个非叶子节点（arr.length/2 - 1）开始,从左至右，从下至上
     * 2.此时，整个序列的最大值就是堆顶的根节点
     * 3.将其与末尾元素进行交换，此时末尾为最大值
     * 4.然后将剩余的 n-1 个元素重新构建成一个堆，这个会得到n个元素的次小值，如此反复，便能得到一个有序序列
     *
     *
     *
     * 赫夫曼树 huffman tree
     * 1.给定n个权值作为n个叶子节点，构造一颗二叉树，若该属的带权路劲长度（wpl）达到最小，称这样的二叉树为
     * 最优二叉树，也称为赫夫曼树
     * 2.赫夫曼树是带权路径最短的树，权值较大的节点离根节点较近
     *
     * 路径和路径长度：在一棵树中，从一个节点往下可以达到的孩子或孙子节点之间的通路，称为路径；通路中分支的
     * 数目为路径长度；若规定根节点的层数为1，则从根节点到第L层节点的路径长度为 L-1
     *
     * 节点的权及带权路径长度：若将树中节点赋值给某个有某种含义的数值，则这个数值称为该节点的权；节点的带权
     * 路径长度为：从根节点到该节点之间的路径长度乘以该节点的权值
     *
     * 数的带权路径长度：所有叶子节点带权路径长度之和，记为wpl(weighted path length),权值越大的节点离
     * 根节点越近的二叉树才为最优二叉树，wpl最小的就是赫夫曼树。
     *
     * 构建赫夫曼树
     * 1.从小到大进行排序，将每一个数，每个数据都是一个节点，每个节点可以看成是一个最简单的二叉树
     * 2.取出根节点权值最小的两颗二叉树
     * 3.组成一颗新的二叉树，该新的二叉树的根节点的权值是前面两个可二叉树根节点权值之和
     * 4.再将这颗新的二叉树，以根节点的权值大小再次排序，重复1~4步骤，直到数据中所有数据都被处理，就
     * 得到赫夫曼树
     *
     *
     * 赫夫曼编码 huffman coding
     * 1. 是一种编码方式，属于一种程序算法
     * 2. 是赫夫曼树在电信通信中的经典应用之一
     * 3. 广泛的应用在数据文件压缩，压缩比在20%~90%之间
     * 4. 是可变字长编码（VLC）的一种
     *
     * 赫夫曼编码原理刨析：
     * 1. 传入一个字符串，统计字符串中每个字符出现的次数
     * 2. 按照字符出现的次数构建一个赫夫曼树（wpl最短），次数作为权值
     * 3. 根据赫夫曼数，给各个字符规定编码（前缀编码），向左的路径为0，向右的路径为1
     * 4. 按照上面的赫夫曼编码，得到字符串对应的编码（这里使用无损压缩）
     * 5. 得到长度，以及压缩率等
     *
     * 赫夫曼编码满足前缀编码，即字符的编码都不能是其他字符编码的前缀，不会造成匹配的多义性
     *
     * 注意：这个赫夫曼树根据排序的方法不同，可能会不一样，这样对应的赫夫曼编码也不完全一样，但是wpl是一样的
     * 都是最小的
     *
     *
     * eg:根据赫夫曼编码压缩数据原理，创建 "......" 对应的赫夫曼树
     * 1. Node{data(存放数据), weight(权值), left, right}
     * 2. 得到字符串对应的 byte[] 数组
     * 3. 编写一个方法，将构建赫夫曼树Node节点存放到list中，形式 [Node[data= , weight = ], Node[data= , weight= ],...]
     * 4. 通过list创建对应的赫夫曼树
     *
     * map遍历
     * Map<Integer, Integer> map = new HashMap<>();
     *
     * 1.遍历key-value
     * for(Map<Integer, Integer> entry : map.entrySet()){
     *     System.out.println(entry.getKey() + entry.getValue());
     * }
     *
     * 2.遍历key或value
     * for(Integer key : map.keySet()){
     *    System.out.println(key);
     * }
     *
     * for(Integer value : map.values()){
     *    System.out.println(value);
     * }
     *
     * 3.使用Iterator遍历
     * Iterator<Map.Entry<Integer, Integer>> entries = map.entrySet().iterator();
     * while(entries.hashNext()){
     *     Map.Entry<Integer, Integer> entry = entrues.next();
     *     System.out.println(entry.getKey() + entry.getValue());
     * }
     *
     *
     *
     *
     */

    public static void main(String[] args) {


        ArrayList<Object> list = new ArrayList<>();
    }
}
