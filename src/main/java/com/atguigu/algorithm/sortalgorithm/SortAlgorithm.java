package com.atguigu.algorithm.sortalgorithm;

public class SortAlgorithm {

    public static void main(String[] args) {

        /**
         * 排序算法（将一组数据，以指定的顺序进行排列的过程）
         *
         * 1.内部排序（使用内存）
         *   将需要处理的所有数据加载到内部存储器（内存）中进行排序
         *
         *   插入排序
         *   1）直接插入排序
         *   2）希尔排序
         *   选择排序
         *   1）简单选择排序
         *   2）堆排序
         *   交换排序
         *   1）快速排序
         *   2）冒泡排序
         *   归并排序
         *   基数排序
         *
         * 2.外部排序（使用内存和外存结合）
         *   数据量过大，无法全部加载到内存，需要借助外部存储（文件等）进行排序
         *
         *
         *
         * 冒泡排序（bubble sorting)：
         * 通过对待排序序列从前向后（从下表较小的元素开始）依次比较相邻元素的值，若发现逆序则交换，使值比较大
         * 的元素逐渐从前向后移动
         * 优化：
         * 在排序过程中设立一个标志flag,判断元素是否进行过交换，从而减少不必要的比较
         *
         *
         * 选择排序（select sorting）：
         * 从欲排序的数组中，按指定的规则选择出一个数，按照一定的规则交换位置后达到排序的效果
         * 第一次从arr[0]~arr[n-1]中选取最小值与arr[0]交换，第二次从arr[1]~arr[n-1]中选取最小值与arr[1]，...
         * 第i次从arr[i]~arr[n-1]中选取最小值与arr[i]交换，总共通过n-1次，得到一个按排序码从小到大的有序序列
         *
         * 1.选择排序一共有 arr.length-1 轮排序
         * 2.每一轮排序是一个循环
         * 2.1 先假定当前这个书就是最小数
         * 2.2 然后和后面的每个数进行比较，发现比他小的数，就重新确定最小数，并得到下标
         * 2.3 当遍历到数组的最后时，就得到本轮最小数和下标
         * 2.4 交换
         *
         *
         *
         * 插入排序（insert sorting）
         * 把n个待排序的元素看成是一个有序表和一个无序表，开始时有序表只有一个元素，无序表有n-1个元素，
         * 排序的过程中每次从无序表中取出第一个元素，把他的排序码依次与有序表中元素的排序码进行比较，将他
         * 插入到有序表中的合适位置，使之成为有序表
         *
         *
         * 希尔排序（shell sorting）：插入排序的优化
         * 写入排序时把记录按下标的一定增量分组，对每组使用直接插入排序，
         * 随着增量逐渐减少，每组包含的关键字越来越多，当增量减至1时，整个文件刚好本份为一组
         *
         * eg:一个数组有10个元素 {8，9，1，7，2，3，5，4，6，0}
         * 初始增量 gap = length / 2 = 5，即整个数组被分为5组，{8，3}，{9，5}，{1，4}，{7，6}，{2，0}
         * 对这5组进行直接插入排序  {3，5，1，6，0，8，9，4，7，2}
         * 然后缩小增量，gap = 5 / 2 = 2,即被分为2组，{3，1，0，9，7}，{5，6，8，4，2}
         * 对着2组进行直接插入排序  {0，2，1，4，3，5，7，6，9，8}
         * 然后缩小增量，gap = 2 / 2 = 1,即被分为1组，{0，2，1，4，3，5，7，6，9，8}
         * 对这1组进行直接插入排序  {0，1，2，3，4，5，6，7，8，9}
         *
         * 1.希尔排序时，对有序序列插入时采用 交换发（当前元素大于加上步长后元素，说明交换），效率较低
         * 2.希尔排序时，对有序序列插入时采用 移动发
         *
         *
         *
         * 快速排序（quick sorting）
         * 通过一趟排序将要排序的数据分成独立的两部分，其中一部分比另一部分的数据都要小，然后再按照此方法对
         * 两个独立的数据进行排序，整个过程可以递归进行
         * 1.取数组最左边位左点，最右边位右点，中间值位基准点
         *   int l = left; int r = right; int pivot = (left + right)/2
         * 2.左点向右走，直到大于中间值，右点向左走，直到小于中间点，交换左右点的值
         * 3.直到所有小于中间点的值都位于左边，大于中间点的值由位于右边
         * 4.对中间值两边的有序序列递归调用自身排序方法，将左右两个数组排序
         *
         *
         *
         * 归并排序（merge sorting)
         * 采用分治策略
         * 不断地将一个大数组分解成两个小数组，直到不能分解，最后采用合并思想对已有序的数组进行合并
         * 将两个有序的子序列合并为一个有序序列：
         * 1.比较左右两边两个有序序列的值，将小的数填充到临时数组temp中，将移动数据的对应下标移动一位
         * 2.重复比较 + 填充，的步骤，当一边的数据全部移完，将另一边的数据依次填充到temp中，
         * 3.将temp中的数据全部考到全数组中
         *
         *
         * 基数排序（radix sorting）
         * 属于分配式排序（distribution sort），又称桶子法（bucket sort）,通过键值的各个位的值，将要排序
         * 的元素分配至某些"桶"中，达到排序
         *
         * 属于效率高的稳定性排序法，是桶排序的扩展
         * 经典的空间换时间算法，占用内存空间很大，当对海量数据进行排序时，容易造成outOfMemoryError(java heap space)
         *
         * 实现：将整数按位数切割成不同的数字，然后按每个位数分别比较
         *
         * 基本思想：
         * 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零，然后从最低位开始，依次进行一次排序
         *
         * eg: int[] arr = {53, 3, 542, 748, 14, 214} 使用基数排序，进行升序排序
         * 第一轮：将每个元素的个位数取出，然后看这个数应该放在那个对应的桶中(一个一维数组,编号0~9)
         *        按照这个桶的顺序（一维数组的下标依次取出这个数），放入原来的数组
         *        0
         *        1
         *        2  542
         *        3  53    3
         *        4  14    214
         *        5
         *        6
         *        7
         *        8  748
         *        9
         *        第一轮排序后：{542，53，3，14，214，748}
         * 第二轮：将每个元素的十位数取出，然后看这个数应该放在那个对应的桶中(一个一维数组)
         *        按照这个桶的顺序（一维数组的下标依次取出这个数），放入原来的数组
         *        第二轮排序后: {3, 14, 214, 542, 748, 53}
         * 第三轮：将每个元素的十位数取出，然后看这个数应该放在那个对应的桶中(一个一维数组)
         *        按照这个桶的顺序（一维数组的下标依次取出这个数），放入原来的数组
         *        第三轮排序后：{3, 14, 53, 214, 542, 748}
         *
         *
         * 注：数组中有负数的时候，我们不用基数排序来进行排序
         *
         *
         *
         *
         * 常用排序算法总结和对比()
         *           平均时间复杂度    空间复杂度    排序方式     稳定性
         * 冒泡排序    O(n^2)         O(1)         in-place    稳定
         * 选择排序                                in-place    不稳定
         * 插入排序                                in-place    稳定
         * 希尔排序    O(n logn)      O(1)         in-place    不稳定
         * 归并排序                   O(n)         out-place   稳定
         * 快速排序                   O(logn)      in-place    不稳定
         * 堆排序                     O(1)         in-place    不稳定
         * 基数排序    O(n + k)       O(n + k)     out-place   不稳定
         *
         * 稳定：如果原本 a 在 b 的前面，而 a=b ，排序之后 a 任然在 b 的前面
         * 内排序：所有排序操作都在内存中完成
         * 外排序：由于数据太大，因此把数据加载到磁盘中，而排序通过磁盘和内存的数据传输才能完成
         *
         * 时间复杂度：一个算法执行所耗费的时间
         * 空间复杂度：运行完一个程序所需要的内存大小
         *
         * n:数据规模
         * k:桶的个数
         * in-place: 不占用额为内存
         * out-place:占用额为内存
         *
         *
         *
         *
         *
         *
         *
         *
         *
         *
         *
         *
         *
         *
         *
         *
         */
    }
}
