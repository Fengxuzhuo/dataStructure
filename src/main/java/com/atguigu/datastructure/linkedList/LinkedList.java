package com.atguigu.datastructure.linkedList;

public class LinkedList {

    public static void main(String[] args) {

        /*
        链表：有序的列表，分带头节点的链表和没有头节点的链表
        1）是链式存储，以结点的方式来存储
        2）每个节点包括data域（存放数据）和next域（指向下一个节点）
        3）链表的各个节点不一定是连续的
        4）最后一个节点的next域为null，代表这个链表结束


        单链表面试题
        1）求链表中节点的有效个数
        2）查找单链表中的第k个节点
           思路：
           编写一个方法，接受head节点，同时接受一个index
           index标识倒数第index个节点
           先把链表从头到尾遍历，得到链表的总长度
           得到size后，从链表的第一个开始遍历（size - index)个，就可以得到
           如果找到了，返回该节点，否则返回null

         3)单链表的反转
           思路：
           先定义一个节点reverseHead = new HeroNode()
           从头遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead
           的最前端
           原来的链表的head.next = reverseHead.next实现单链表的反转

         4）从尾到头打印单链表（要求方式1：反向遍历； 方式2：stack栈）
           思路：
           上面题的要求其实就是逆向打印单链表
           方式1：先将单链表进行反转操作，然后再遍历即可，这样会破坏原来单链表的结构，不建议
           方式2：利用栈这个数据结构，将各个节点压入到栈中，利用栈的先进后出原则

           栈：只允许在一段进行添加或删除的线性表，先进后出原则
            Stack<String> stack = new Stack();
            push() 压栈
            pop() 出栈

         5）合并两个有序的单链表，合并之后的链表依然有序



         //双向链表
         使用带头的双向链表实现  -- 英雄排行榜的管理
         单向链表的缺点分析：
         1）查找是只能是一个方向，二双向链表可向前或向后查询
         2）单向链表不能自我删除，需要接触辅助节点temp.temp是代删除节点的前一个节点

         双向链表的每个节点都包含两个:next(指向后一个节点)和 pre(指向前一个节点)

         双向链表的遍历，添加，修改，删除操作
         遍历：和单链表一样，只是可以向前，也可以向后
         添加：默认添加到双向链表的最后
           1）先找到双向链表的最后的节点
           2）让temp.next 指向 新节点newHeroNode,同时newHeroNode.pre指向 temp
         修改：方法发和单链表一样
         删除：双向链表可以实现自我删除
           1）直接找到要删除的节点temp，则 temp.pre.next = temp.next且 temp.next.pre = temp.pre

         双向链表的第二种添加方式（按照编号顺序）


         //单向环形链表：



         //约瑟夫问题(josephu)
         设编号为1~n的n个人围坐一圈，约定编号为k(1<=k<=n)的人从1开始报数，数到m的那个人出列
         他的下一位又从1开始报数，数到m的那个人出列，依次类推，知道所有人出列为止，由此产生一个
         出队编号的序列
         提示：用一个不带头节点的循环链表来处理。先构成一个有n个节点的单循环链表，然后由k点起从
         1开始计数，记到m时，对应节点从链表中删除，然后再从被删除节点的下一个节点又从1开始计数，
         知道最后一个节点从链表中删除

         实现：
         1.数组取模的方式实现
         2.单向环形链表的方式实现（比较形象）


         //创建环形链表思路：
         1）先创建第一个节点first，让first指向该节点，并形成环形
         2）后面没创建一个节点，就把该节点加入到已有的环形链表中即可
         //遍历环形列表
         1）先让一个辅助指针（变量）curBoy,指向first节点
         2）然后通过一个while循环遍历该环形链表即可， curBoy.next = first 结束

         //小孩出圈思路分析
         根据用户的输入，生成一个小孩出圈的顺序
         n=5 即有5个人
         k=1 从第一个人开始报数
         m=2 数2下

         需求创建一个辅助指针helper，指向环形链表的最后这个节点
         小孩报数前，先让first和helper移动 k-1 次
         当小孩报数时，让first和helper同时移动 m-1 次
         这时就可以将first指向的小孩节点出圈
         first = first.next
         helper.next = first
         原来first指向的节点就没有任何引用，就会被回收







         */
    }
}
