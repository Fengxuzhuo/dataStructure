package com.atguigu.linux;

public class HttpTCP {

    /**
     * tcp是面向连接的，发送数据之前，都必须在client <--> server 之间建立一条连接，
     * tcp协议提供可靠的建立连接服务，连接是通过三次握手进行初始化的，三次握手的目的
     * 是同步连接双方的序列号和确认号并交换tcp窗口大小信息。
     *
     * 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence number
     * 为x,然后客户端进入SYN_SEND状态，等待服务器的确认
     * 第二次握手：服务器收到SYN报文段。收到后对这个SYN报文段进行确认，设置Acknowledgment
     * number 为 x+1(Sequence number +1),同时自己还要发送SYN请求信息，将SYM位置为1
     * Sequence number为y,服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，
     * 一并发送给客户端，此时服务器进入SYN_RECV状态
     * 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment number
     * 设置为y+1,向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都
     * 进入ESTABLISHED 状态，完成tcp三次握手。
     * 完成三次握手，客户端和服务端就可以开始传输数据了
     *
     * 当数据传输完毕后，需要断开连接，通过四次分手断开连接
     * 第一次分手：主机1（可以是client，也可以是server），设置Sequence number 和
     * Acknowledgment number,向主机2发送一个FIN报文段，此时主机1进入FIN_WAIT_1
     * 状态，表示主机1没有数据要发送给主机2了
     * 第二次分手：主机2收到了主机1的FIN报文段，向主机1回一个ACK报文段，Acknowledgment
     * number 设置为Sequence number+1,主机1进入FIN_WAIT_2状态，主机2告诉主机1
     * 我也没有数据发送了，可以关闭连接了
     * 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入CLOSE_WAIT
     * 状态
     * 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1
     * 进入TIME_WAIT状态，主机2收到主机1的ACK报文段以后，就关闭连接，此时，主机1
     * 等待2MSL后，依然没有收到回复，则证明server端已经正常关闭，那么，主机1也可以
     * 关闭连接了。
     *
     *
     * 为什么要三次握手：为了防止已失效的连接请求报文段突然又传送到服务端，因此产生错误
     * 为社么要四次分手：tcp协议是一种面向连接的，可靠的，基于字节流的运输层通信协议。
     * tcp是全双工模式，这就意味着，当主机1发送FIN报文段时，指标是主机1没有数据发送了，
     * 主机1告诉主机2，他的数据已经全部发送完了，但是这个时候主机1还是可以接受来自主机
     * 2的数据。当主机2发送ACK报文段时，表示主机2知道主机1没有数据发送了，但是主机2
     * 还是可以发送数据到主机1，当主机2也发送FIN报文段时，表示主机2也没有数据发送了，
     * 就会告诉主机1，我也没有数据发送了，之后彼此就会愉快的中断这次tcp连接了
     *
     *
     *
     *
     */
}
